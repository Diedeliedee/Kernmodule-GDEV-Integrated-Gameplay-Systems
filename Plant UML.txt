@startuml

'Core Systems
class GameManager
{
  -tickManager: TickManager

  +Awake() : void
  +Start() : void
  +Update() : void
}

class ServiceLocator
{
  -services : Dictionary<Type, IService>
  +Add(...) : void
  +Remove(...) : void
  +Get<T>() : void
}

class TickManager
{
  -subscribed : List<IUpdatable> 
  +OnUpdate() : void
  +Add<T>(updatable : T) : T
}

interface IService
interface IUpdatable

GameManager *-- TickManager
TickManager o.. IUpdatable
ServiceLocator o.. IService

'Inventory System Base
interface IInventory <<Service>>
{
  +Add(itemStack : params ItemStack[]) : void
  +Remove(itemStack : params ItemStack[]) : void
  +Contains(itemStack : params ItemStack[]) : bool
}

struct ItemStack
{
  type : ItemData
  amount : int
}

class ItemData
{
  +image : Sprite
}

IInventory --> ItemStack
ItemStack *-- ItemData

'Grid Inventory System
class GridInventory implements IInventory
{
  -itemGrid : Tile[]
}

class Tile
{
  -contents : ItemStack
  +SetContents() : void
  +ChangeValue(amount : int) : void
}

class InventoryManager
{
  -inventory : GridInventory
  -elements : SlotElement[]
  +GetElement(elementTransform : Transform) : TileElement
  -Connect(tiles : Tile[]) : void
}

class SlotElement extends BaseInteractable
{
  -connectedTile : Tile
}

GridInventory *-- Tile
InventoryManager *-- SlotElement
SlotElement *-- Tile

'Interaction System
interface IInteractable
{
  +OnClick(mousePos : Vector2) : void
  +OnRelease(mousePos : Vector2) : void
}

abstract class BaseInteractable implements IInteractable
{
  -element : RectTransform
  +BaseInteractable()
}

class InteractionManager <<Service, Updatable>>
{
  -subscribedElements : Dictionary<RectTransform, IInteractable>
  -selectedElement : RectTransform
  +Subscribe(element : IInteractable, key : RectTransform)
}

InventoryManager *-- GridInventory
InteractionManager .. IInteractable

@enduml